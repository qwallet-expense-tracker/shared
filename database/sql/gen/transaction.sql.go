// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: transaction.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const contributeToGoal = `-- name: ContributeToGoal :exec
select contribute_to_goal(
               $1,
               $2,
               $3,
               $4,
               $5
       )
`

func (q *Queries) ContributeToGoal(ctx context.Context, userID string, goalID string, amount float32, description string, accountNumber string) error {
	_, err := q.db.Exec(ctx, contributeToGoal,
		userID,
		goalID,
		amount,
		description,
		accountNumber,
	)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
select delete_transaction(
               $1,
               $2
       )
`

func (q *Queries) DeleteTransaction(ctx context.Context, transactionID string, userID string) error {
	_, err := q.db.Exec(ctx, deleteTransaction, transactionID, userID)
	return err
}

const deposit = `-- name: Deposit :exec
select create_transaction(
               $1,
               $2,
               $3,
               'CREDIT',
               $4::decimal,
               $5
       )
`

func (q *Queries) Deposit(ctx context.Context, userID string, accountNumber string, categoryID string, amount float32, description string) error {
	_, err := q.db.Exec(ctx, deposit,
		userID,
		accountNumber,
		categoryID,
		amount,
		description,
	)
	return err
}

const getAccountTransactions = `-- name: GetAccountTransactions :many
select id, user_id, account_number, account_name, category_id, type, amount, description, reference_number, status, updated_at, is_deleted
from list_transactions_for_user_by_account(
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
     )
`

func (q *Queries) GetAccountTransactions(ctx context.Context, userID string, accountNumber string, startDate pgtype.Timestamp, endDate pgtype.Timestamp, pageNumber int32, pageSize int32) ([]*Transactionpayload, error) {
	rows, err := q.db.Query(ctx, getAccountTransactions,
		userID,
		accountNumber,
		startDate,
		endDate,
		pageNumber,
		pageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Transactionpayload{}
	for rows.Next() {
		var i Transactionpayload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountNumber,
			&i.AccountName,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.ReferenceNumber,
			&i.Status,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryTransactions = `-- name: GetCategoryTransactions :many
select id, user_id, account_number, account_name, category_id, type, amount, description, reference_number, status, updated_at, is_deleted
from list_transactions_for_user_by_category(
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
     )
`

func (q *Queries) GetCategoryTransactions(ctx context.Context, userID string, categoryID string, startDate pgtype.Timestamp, endDate pgtype.Timestamp, pageNumber int32, pageSize int32) ([]*Transactionpayload, error) {
	rows, err := q.db.Query(ctx, getCategoryTransactions,
		userID,
		categoryID,
		startDate,
		endDate,
		pageNumber,
		pageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Transactionpayload{}
	for rows.Next() {
		var i Transactionpayload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountNumber,
			&i.AccountName,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.ReferenceNumber,
			&i.Status,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGoalTransactions = `-- name: GetGoalTransactions :many
select id, user_id, account_number, account_name, category_id, type, amount, description, reference_number, status, updated_at, is_deleted
from list_transactions_for_user_by_goal(
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
     )
`

func (q *Queries) GetGoalTransactions(ctx context.Context, userID string, goalID string, startDate pgtype.Timestamp, endDate pgtype.Timestamp, pageNumber int32, pageSize int32) ([]*Transactionpayload, error) {
	rows, err := q.db.Query(ctx, getGoalTransactions,
		userID,
		goalID,
		startDate,
		endDate,
		pageNumber,
		pageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Transactionpayload{}
	for rows.Next() {
		var i Transactionpayload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountNumber,
			&i.AccountName,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.ReferenceNumber,
			&i.Status,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionById = `-- name: GetTransactionById :one
select id, user_id, account_number, account_name, category_id, type, amount, description, reference_number, status, updated_at, is_deleted
from get_transaction_by_id(
        $1,
        $2
     )
`

func (q *Queries) GetTransactionById(ctx context.Context, transactionID string, userID string) (*Transactionpayload, error) {
	row := q.db.QueryRow(ctx, getTransactionById, transactionID, userID)
	var i Transactionpayload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountNumber,
		&i.AccountName,
		&i.CategoryID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.ReferenceNumber,
		&i.Status,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return &i, err
}

const getTransactionsByType = `-- name: GetTransactionsByType :many
select id, user_id, account_number, account_name, category_id, type, amount, description, reference_number, status, updated_at, is_deleted
from list_transactions_for_user_by_type(
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
     )
`

func (q *Queries) GetTransactionsByType(ctx context.Context, userID string, transactionType string, startDate pgtype.Timestamp, endDate pgtype.Timestamp, pageNumber int32, pageSize int32) ([]*Transactionpayload, error) {
	rows, err := q.db.Query(ctx, getTransactionsByType,
		userID,
		transactionType,
		startDate,
		endDate,
		pageNumber,
		pageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Transactionpayload{}
	for rows.Next() {
		var i Transactionpayload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountNumber,
			&i.AccountName,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.ReferenceNumber,
			&i.Status,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactions = `-- name: GetUserTransactions :many
select id, user_id, account_number, account_name, category_id, type, amount, description, reference_number, status, updated_at, is_deleted
from list_transactions_for_user(
        $1,
        $2,
        $3,
        $4,
        $5
     )
`

func (q *Queries) GetUserTransactions(ctx context.Context, userID string, startDate pgtype.Timestamp, endDate pgtype.Timestamp, pageNumber int32, pageSize int32) ([]*Transactionpayload, error) {
	rows, err := q.db.Query(ctx, getUserTransactions,
		userID,
		startDate,
		endDate,
		pageNumber,
		pageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Transactionpayload{}
	for rows.Next() {
		var i Transactionpayload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountNumber,
			&i.AccountName,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.ReferenceNumber,
			&i.Status,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transfer = `-- name: Transfer :exec
select account_to_account_transfer(
               $1,
               $2,
               $3,
               $4,
               $5
       )
`

func (q *Queries) Transfer(ctx context.Context, userID string, fromAccountNumber string, toAccountNumber string, amount float32, description string) error {
	_, err := q.db.Exec(ctx, transfer,
		userID,
		fromAccountNumber,
		toAccountNumber,
		amount,
		description,
	)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
select update_transaction(
               $1,
               $2,
               $3,
               $4,
               $5,
               $6::decimal,
               $7
       )
`

func (q *Queries) UpdateTransaction(ctx context.Context, transactionID string, userID string, accountNumber string, categoryID string, transactionType string, amount float32, description string) error {
	_, err := q.db.Exec(ctx, updateTransaction,
		transactionID,
		userID,
		accountNumber,
		categoryID,
		transactionType,
		amount,
		description,
	)
	return err
}

const withdraw = `-- name: Withdraw :exec
select create_transaction(
               $1,
               $2,
               $3,
               'DEBIT',
               $4::decimal,
               $5
       )
`

func (q *Queries) Withdraw(ctx context.Context, userID string, accountNumber string, categoryID string, amount float32, description string) error {
	_, err := q.db.Exec(ctx, withdraw,
		userID,
		accountNumber,
		categoryID,
		amount,
		description,
	)
	return err
}
